; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -O0 -verify-machineinstrs -mtriple=x86_64-unknown-unknown --show-mc-encoding -mattr=+avxneconvert | FileCheck %s --check-prefixes=CHECK,X64
; RUN: llc < %s -O0 -verify-machineinstrs -mtriple=i686-unknown-unknown --show-mc-encoding -mattr=+avxneconvert | FileCheck %s --check-prefixes=CHECK,X86

define <4 x float> @test_int_x86_vbcstnebf162ps128(ptr %A) {
; X64-LABEL: test_int_x86_vbcstnebf162ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vbcstnebf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnebf162ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vbcstnebf162ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vbcstnebf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnebf162ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vbcstnebf162ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vbcstnebf162ps128(ptr %A)

define <8 x float> @test_int_x86_vbcstnebf162ps256(ptr %A) {
; X64-LABEL: test_int_x86_vbcstnebf162ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vbcstnebf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnebf162ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vbcstnebf162ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vbcstnebf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnebf162ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vbcstnebf162ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vbcstnebf162ps256(ptr %A)

define <4 x float> @test_int_x86_vbcstnesh2ps128(ptr %A) {
; X64-LABEL: test_int_x86_vbcstnesh2ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vbcstnesh2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnesh2ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vbcstnesh2ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vbcstnesh2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnesh2ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vbcstnesh2ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vbcstnesh2ps128(ptr %A)

define <8 x float> @test_int_x86_vbcstnesh2ps256(ptr %A) {
; X64-LABEL: test_int_x86_vbcstnesh2ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vbcstnesh2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnesh2ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vbcstnesh2ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vbcstnesh2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vbcstnesh2ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vbcstnesh2ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vbcstnesh2ps256(ptr %A)

define <4 x float> @test_int_x86_vcvtneebf162ps128(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneebf162ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneebf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneebf162ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneebf162ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneebf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneebf162ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vcvtneebf162ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vcvtneebf162ps128(ptr %A)

define <8 x float> @test_int_x86_vcvtneebf162ps256(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneebf162ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneebf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneebf162ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneebf162ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneebf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneebf162ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vcvtneebf162ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vcvtneebf162ps256(ptr %A)

define <4 x float> @test_int_x86_vcvtneeph2ps128(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneeph2ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneeph2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneeph2ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneeph2ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneeph2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneeph2ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vcvtneeph2ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vcvtneeph2ps128(ptr %A)

define <8 x float> @test_int_x86_vcvtneeph2ps256(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneeph2ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneeph2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneeph2ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneeph2ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneeph2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneeph2ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vcvtneeph2ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vcvtneeph2ps256(ptr %A)

define <4 x float> @test_int_x86_vcvtneobf162ps128(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneobf162ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneobf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneobf162ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneobf162ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneobf162ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneobf162ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vcvtneobf162ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vcvtneobf162ps128(ptr %A)

define <8 x float> @test_int_x86_vcvtneobf162ps256(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneobf162ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneobf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneobf162ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneobf162ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneobf162ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneobf162ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vcvtneobf162ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vcvtneobf162ps256(ptr %A)

define <4 x float> @test_int_x86_vcvtneoph2ps128(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneoph2ps128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneoph2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneoph2ps128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneoph2ps128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneoph2ps128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneoph2ps128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <4 x float> @llvm.x86.vcvtneoph2ps128(ptr %A)
  ret <4 x float> %ret
}
declare <4 x float> @llvm.x86.vcvtneoph2ps128(ptr %A)

define <8 x float> @test_int_x86_vcvtneoph2ps256(ptr %A) {
; X64-LABEL: test_int_x86_vcvtneoph2ps256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneoph2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneoph2ps256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneoph2ps256:
; X86:       # %bb.0:
; X86-NEXT:    pushl %eax # encoding: [0x50]
; X86-NEXT:    .cfi_def_cfa_offset 8
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx # encoding: [0x8b,0x4c,0x24,0x08]
; X86-NEXT:    movl %esp, %eax # encoding: [0x89,0xe0]
; X86-NEXT:    movl %ecx, (%eax) # encoding: [0x89,0x08]
; X86-NEXT:    calll llvm.x86.vcvtneoph2ps256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneoph2ps256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    popl %eax # encoding: [0x58]
; X86-NEXT:    .cfi_def_cfa_offset 4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x float> @llvm.x86.vcvtneoph2ps256(ptr %A)
  ret <8 x float> %ret
}
declare <8 x float> @llvm.x86.vcvtneoph2ps256(ptr %A)

define <8 x bfloat> @test_int_x86_vcvtneps2bf16128(<4 x float> %A) {
; X64-LABEL: test_int_x86_vcvtneps2bf16128:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneps2bf16128@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneps2bf16128@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneps2bf16128:
; X86:       # %bb.0:
; X86-NEXT:    calll llvm.x86.vcvtneps2bf16128@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneps2bf16128@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x bfloat> @llvm.x86.vcvtneps2bf16128(<4 x float> %A)
  ret <8 x bfloat> %ret
}
declare <8 x bfloat> @llvm.x86.vcvtneps2bf16128(<4 x float> %A)

define <8 x bfloat> @test_int_x86_vcvtneps2bf16256(<8 x float> %A) {
; X64-LABEL: test_int_x86_vcvtneps2bf16256:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax # encoding: [0x50]
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq llvm.x86.vcvtneps2bf16256@PLT # encoding: [0xe8,A,A,A,A]
; X64-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneps2bf16256@PLT-4, kind: FK_PCRel_4
; X64-NEXT:    popq %rax # encoding: [0x58]
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_int_x86_vcvtneps2bf16256:
; X86:       # %bb.0:
; X86-NEXT:    calll llvm.x86.vcvtneps2bf16256@PLT # encoding: [0xe8,A,A,A,A]
; X86-NEXT:    # fixup A - offset: 1, value: llvm.x86.vcvtneps2bf16256@PLT-4, kind: FK_PCRel_4
; X86-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; X86-NEXT:    retl # encoding: [0xc3]
  %ret = call <8 x bfloat> @llvm.x86.vcvtneps2bf16256(<8 x float> %A)
  ret <8 x bfloat> %ret
}
declare <8 x bfloat> @llvm.x86.vcvtneps2bf16256(<8 x float> %A)

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
